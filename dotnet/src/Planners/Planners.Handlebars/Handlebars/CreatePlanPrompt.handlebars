{{#message role="system"}}## Instructions
Explain how to achieve the user's goal with the available helpers with a Handlebars template.

## Example
If the user wanted you to {{#if allowLoops}}generate 10 random numbers and use them in another helper{{else}}return the sum of 3 numbers{{/if}}, you could answer with the following.{{/message}}
{{#message role="user"}}Please show me how to write a Handlebars template that achieves the following goal.

{{#if allowLoops}}## Goal
I want you to generate 10 random numbers and send them to another helper.
{{else}}## Goal
What's the sum of 5+10+15?
{{~/if}}{{/message}}
{{#message role="assistant"}}Here's the Handlebars template that achieves the goal:
```handlebars
{{#if allowLoops}}
\{{!-- Step 1: Initialize the count --}}
\{{
set
  "count"
  10
}}
\{{!-- Step 2: Loop using the count --}}
\{{
#each
  (range
    1
    (get
      "count"
    )
  )
}}
  \{{
set
    "index"
    this
}}
  \{{!-- Step 3: Create random number --}}
  \{{
set
    "randomNumber"
    (Example{{reservedNameDelimiter
}}Random
      seed=(get
        "index"
      )
    )
  }}
  \{{!-- Step 4: Call example helper with random number and print the result to the screen --}}
  \{{
json
    (Example{{reservedNameDelimiter
}}Helper
      input=(get
        "randomNumber"
      )
    )
  }}
\{{/each}}
{{else}}
\{{!-- Step 1: Initialize the variables --}}
\{{
set
  "num1"
  5
}}
\{{
set
  "num2"
  10
}}
\{{
set
  "num3"
  15
}}
\{{!-- Step 2: Call the Example-AddNums helper with the variables and store the result --}}
\{{
set
  "sum"
  (Example{{reservedNameDelimiter
}}AddNums
    num1=(get
      "num1"
    )
    num2=(get
      "num2"
    )
    num3=(get
      "num3"
    )
  )
}}
\{{!-- Step 3: Print the result using the json helper --}}
\{{
json
  (get
    "sum"
  )
}}
{{/if}}
```{{/message}}
{{#message role="system"}}Now let's try the real thing.{{/message}}
{{#message role="user"}}Please show me how to write a Handlebars template that achieves the following goal with the available helpers.

## Goal
{{goal}}

## Out-of-the-box helpers
The following helpers are available to you:
- `\{{#if}}\{{/if}}`
- `\{{#unless}}\{{/unless}}`{{#if allowLoops}}
- `\{{#each}}\{{/each}}`{{/if}}
- `\{{#with}}\{{/with}}`

{{#if allowLoops}}
## Loop helpers
If you need to loop through a list of values with `\{{#each}}`, you can use the following helpers:
- `\{{range}}` – Generates a sequence of integral numbers within a specified range, inclusive of last value.
- `\{{array}}` – Generates an array of values from the given values.

IMPORTANT: `range` and `array` are the only supported data structures. Others like `hash` are not supported. Also, you cannot use any methods or properties on the built-in data structures, such as `array.push` or `range.length`.

## Math helpers
If you need to do basic operations, you can use these two helpers with numerical values:
- `\{{add}}` – Adds two values together.
- `\{{subtract}}` – Subtracts the second value from the first.

{{/if}}
## Comparison helpers
If you need to compare two values, you can use the `\{{equal}}` helper.
To use the {{#if allowLoops}}math and {{/if}}comparison helpers, you must pass in two positional values. For example, to check if the variable `var` is equal to number `1`, you would use the following helper like so: `\{{#if (equal var 1)}}\{{/if}}`.

## Variable helpers
If you need to create or retrieve a variable, you can use the following helpers:
- `\{{set}}` – Creates a variable with the given name and value. It does not print anything to the template, so you must use `\{{json}}` to print the value.
- `\{{get}}` – Retrieves the value of a variable with the given name.
- `\{{json}}` – Generates a JSON string from the given value; no need to use on strings.
- `\{{concat}}` – Concatenates the given values into a string.

{{#if (or complexTypeDefinitions complexSchemaDefinitions)}}
## Complex types
Some helpers require arguments that are complex objects. The JSON schemas for these complex objects are defined below:

{{#each complexTypeDefinitions}}
### {{Name}}:
{
  "type": "object",
  "properties": {
{{#each Properties}}
    "{{Name}}": {
      "type": "{{ParameterType.Name}}",
    },
{{/each}}
  }
}

{{/each}}
{{#each complexSchemaDefinitions}}
### {{@key}}:
{{this}}

{{/each}}
{{/if}}
## Custom helpers
Lastly, you also have the following Handlebars helpers that you can use:

{{#each functions}}
### `{{doubleOpen}}{{PluginName}}{{../reservedNameDelimiter}}{{Name}}{{doubleClose}}`
Description: {{Description}}
Inputs:
{{#each Parameters}}
    - {{Name}}:
{{~#if ParameterType}} {{ParameterType.Name}} -
{{~else}}
{{~#if Schema}} {{getSchemaTypeName this}} -{{/if}}
{{~/if}}
{{~#if Description}} {{Description}}{{/if}}
{{~#if IsRequired}} (required){{else}} (optional){{/if}}
{{/each}}
Output:
{{~#if ReturnParameter}}
{{~#if ReturnParameter.ParameterType}} {{ReturnParameter.ParameterType.Name}}
{{~else}}
{{~#if ReturnParameter.Schema}} {{getSchemaReturnTypeName ReturnParameter}}
{{else}} string{{/if}}
{{~/if}}
{{~#if ReturnParameter.Description}} - {{ReturnParameter.Description}}{{/if}}
{{/if}}

{{/each}}
IMPORTANT: You can only use the helpers that are listed above. Do not use any other helpers that are not listed here. For example, do not use `\{{log}}` or any `\{{Example}}` helpers, as they are not supported.{{/message}}
{{#message role="system"}}
## Tips and tricks
- Add a comment above each step to describe what the step does.
- Use the `\{{set}}` and `\{{get}}` helpers to save and retrieve the results of another helper so you can use it later in the template without wasting resources.
- There are no initial variables available to you. You must create them yourself using the `\{{set}}` helper and then access them using `\{{get}}`.
- Do not make up values. Use the helpers to generate the data you need or extract it from the goal.
- Keep data well-defined. Each variable should have a unique name. Create and assign each variable only once.
- Do not pass raw data to helpers. Use variables instead.
- Be extremely careful about types. For example, if you pass an array to a helper that expects a number, the template will error out.
{{#if allowLoops}}- Avoid using loops. Try a solution without before you deploy a loop.{{/if}}
- There is no need to check your results in the template.
- Do not nest sub-expressions or helpers because it will cause the template to error out.
- Each step should contain only one helper call.

## Start
Now take a deep breath and accomplish the task:
1. Keep the template short and sweet. Be as efficient as possible.
2. Do not use helpers or functions that were not provided to you, and be especially careful to not assume or make up any helpers or operations that were not explicitly defined already.
3. If, and ONLY if none of the available helpers can achieve the goal, thwo an exception and respond with "Additional helpers may be required", followed by the plugin and the source code:

For each required plugin write the production, ready-to-use C# kernelfunction targeting .NET 6.
Generate only one plugin file with all of the kernelfunctions that will be required to achieve the goal. You MUST use only string return types. The KernelFunction signatures MUST be ""public string"". You MUST NOT use any other return types. The function MUST NOT be async.
Break functionalities up into separate KernelFunctions. Do not create a single KernelFunction that does everything.
You MUST NOT write any TODOs or placeholders, implement the full functionality to the best of your ability. Do not write any placeholder code.

The class MUST contain ""using Microsoft.SemanticKernel"", the class name MUST be ""GeneratedPlugin"", and the namespace MUST be ""Plugins"". The class MUST be a "public sealed class". The class and functions MUST NOT be static.
After the code snipper you MUST list all of the assemblies that need to be imported in order to compile the plugin prefixed by "- ". Make sure you include all information on the assembly in the following format : "System.Runtime, Version=7.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a".
The line preceding the assembly list MUST start with "Assemblies required"
Here is an example of the assemblies block:

```Assemblies
Assemblies required:
- System.Runtime, Version=7.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
- System.IO.FileSystem, Version=7.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
- System.Linq, Version=7.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
- Microsoft.SemanticKernel, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
```

Here is an example of a simple lower case to upper case plugin:

```csharp
using System.ComponentModel;
using Microsoft.SemanticKernel;

namespace Plugins;

public sealed class StaticTextPlugin
{
    [KernelFunction, Description("Change all string chars to uppercase")]
    public static string Uppercase([Description("Text to uppercase")] string input) =>
        input.ToUpperInvariant();

    [KernelFunction, Description("Append the day variable")]
    public static string AppendDay(
        [Description("Text to append to")] string input,
        [Description("Value of the day to append")] string day) =>
        input + day;
}
```

Here is another exmaple of a plugin. This is a math plugin that incorporates several functions:

```csharp
using System.ComponentModel;

namespace Microsoft.SemanticKernel.Plugins.Core;

/// <summary>
    /// MathPlugin provides a set of functions to make Math calculations.
    ///
</summary>
public sealed class MathPlugin
{
    /// <summary>
    /// Returns the Addition result of initial and amount values provided.
    ///
</summary>
    ///
<param name="value">Initial value to which to add the specified amount</param>
    ///
<param name="amount">The amount to add as a string.</param>
    /// <returns>The resulting sum as a string.</returns>
    [KernelFunction, Description("Adds an amount to a value")]
    [return: Description("The sum")]
    public int Add(
        [Description("The value to add")] int value,
        [Description("Amount to add")] int amount) =>
        value + amount;

    /// <summary>
    /// Returns the Sum of two provided numbers.
    ///
</summary>
    ///
<param name="value">Initial value from which to subtract the specified amount</param>
    ///
<param name="amount">The amount to subtract as a string.</param>
    /// <returns>The resulting subtraction as a string.</returns>
    [KernelFunction, Description("Subtracts an amount from a value")]
    [return: Description("The difference")]
    public int Subtract(
        [Description("The value to subtract")] int value,
        [Description("Amount to subtract")] int amount) =>
        value - amount;
}
```

Again, do not generate any C# helper code unless you could not achieve the goal.

4. Always start by identifying any important values in the goal. Then, use the `\{{set}}` helper to create variables for each of these values.
5. The template should use the \{{json}} helper at least once to output the result of the final step.
6. Don't forget to use the tips and tricks otherwise the template will not work.
7. Don't close the ``` handlebars block until you're done with all the steps.{{/message}}